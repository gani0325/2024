"""
마법의 숲 탐색

💛 문제
정령들이 R행 C열의 격자 형태로 이루어진 마법의 숲을 탐색하려고 합니다. 
격자는 가장 위를 1행, 가장 아래를 R행으로 합니다.

숲의 동쪽, 서쪽, 남쪽은 마법의 벽으로 막혀 있으며, 
정령들은 숲의 북쪽을 통해서만 숲에 들어올 수 있습니다.

총 K명의 정령은 각자 골렘을 타고 숲을 탐색합니다. 
각 골렘은 십자 모양의 구조를 가지고 있으며, 중앙 칸을 포함해 총 5칸을 차지합니다. 
골렘의 중앙을 제외한 4칸 중 한 칸은 골렘의 출구입니다. 
정령은 어떤 방향에서든 골렘에 탑승할 수 있지만 골렘에서 내릴 때에는 정해진 출구를 통해서만 내릴 수 있습니다.

i번째로 숲을 탐색하는 골렘은 숲의 가장 북쪽에서 시작해 골렘의 중앙이 c i 열이 되도록 하는 위치에서 내려오기 시작합니다. 
초기 골렘의 출구는 d i 의 방향에 위치해 있습니다.

골렘은 숲을 탐색하기 위해 다음과 같은 우선순위로 이동합니다. 
더 이상 움직이지 못할 때까지 해당 과정을 반복합니다.

(1) 남쪽으로 한 칸 내려갑니다.
(2) (1)의 방법으로 이동할 수 없으면 서쪽 방향으로 회전하면서 내려갑니다.
위 그림의 초록색 칸들이 비어있을 때에만 서쪽 방향으로 회전하면서 내려갈 수 있습니다. 
이 때 서쪽 방향으로 한 칸 이동을 한 뒤 내려가기 때문에 골렘을 기준으로 서쪽 한 칸이 모두 비어 있어야 함에 유의합니다. 
또한 이렇게 이동할 때 출구가 반시계방향으로 이동합니다.
(3) (1)과 (2)의 방법으로 이동할 수 없으면 동쪽 방향으로 회전하면서 내려갑니다.
위 그림의 초록색 칸들이 비어있을 때에만 동쪽 방향으로 회전하면서 내려갈 수 있습니다. 
이 때 동쪽 방향으로 한 칸 이동을 한 뒤 내려가기 때문에 골렘을 기준으로 동쪽 한 칸이 모두 비어 있어야 함에 유의합니다. 
또한 이렇게 이동할 때 출구가 시계방향으로 이동합니다.
골렘이 이동할 수 있는 가장 남쪽에 도달해 더이상 이동할 수 없으면 정령은 골렘 내에서 상하좌우 인접한 칸으로 이동이 가능합니다. 
단, 만약 현재 위치하고 있는 골렘의 출구가 다른 골렘과 인접하고 있다면 해당 출구를 통해 다른 골렘으로 이동할 수 있습니다.
정령은 갈 수 있는 모든 칸 중 가장 남쪽의 칸으로 이동하고 이동을 완전히 종료합니다. 이때 정령의 위치가 해당 정령의 최종 위치가 됩니다.

이 문제에서는 정령의 최종 위치의 행 번호의 합을 구해야 하기에 각 정령이 도달하게 되는 최종 위치를 누적해야 합니다.
아래의 그림처럼 만약 골렘이 최대한 남쪽으로 이동했지만 골렘의 몸 일부가 여전히 숲을 벗어난 상태라면, 
해당 골렘을 포함해 숲에 위치한 모든 골렘들은 숲을 빠져나간 뒤 다음 골렘부터 새롭게 숲의 탐색을 시작합니다. 
단, 이 경우에는 정령이 도달하는 최종 위치를 답에 포함시키지 않습니다.

골렘들이 숲에 진입함에 따라 각 정령들이 최종적으로 위치한 행의 총합을 구하는 프로그램을 작성하세요. 
숲이 다시 텅 비게 돼도 행의 총합은 누적되는 것에 유의합니다.

🧡 입력 형식
첫 번째 줄에는 숲의 크기를 의미하는 R, C, 정령의 수 K가 공백을 사이에 두고 주어집니다.

그다음 줄부터 K개의 줄에 거쳐 각 골렘이 출발하는 열 c i, 골렘의 출구 방향 정보 d i 가 공백을 사이에 두고 주어집니다.

골렘의 출구 방향 정보 d i 는 0과 3 사이의 수로 주어지며 각각의 숫자 0,1,2,3 은 북, 동, 남, 서쪽을 의미합니다.

5 ≤ R, C ≤ 70
1 ≤ K ≤ 1000
2 ≤ c i ≤ C - 1
0 ≤ d i ≤ 3

💚 출력 형식
첫번째 줄에 각 정령들이 최종적으로 위치한 행의 총합을 출력하세요.

⭐ 입출력
입력:
6 5 6
2 3
2 0
4 2
2 0
2 0
2 2

출력:
29
"""

from collections import deque

MAX_L = 70

R, C, K = 0, 0, 0 # 행, 열, 골렘의 개수를 의미합니다
A = [[0] * MAX_L for _ in range(MAX_L + 3)] # 실제 숲을 [3~R+2][0~C-1]로 사용하기위해 행은 3만큼의 크기를 더 갖습니다
dy = [-1, 0, 1, 0]
dx = [0, 1, 0, -1]
isExit = [[False] * MAX_L for _ in range(MAX_L + 3)] # 해당 칸이 골렘의 출구인지 저장합니다
answer = 0 # 각 정령들이 도달할 수 있는 최하단 행의 총합을 저장합니다

# (y, x)가 숲의 범위 안에 있는지 확인하는 함수입니다
def inRange(y, x):
    return 3 <= y < R + 3 and 0 <= x < C

# 숲에 있는 골렘들이 모두 빠져나갑니다
def resetMap():
    for i in range(R + 3):
        for j in range(C):
            A[i][j] = 0
            isExit[i][j] = False

# 골렘의 중심이 y, x에 위치할 수 있는지 확인합니다.
# 북쪽에서 남쪽으로 내려와야하므로 중심이 (y, x)에 위치할때의 범위와 (y-1, x)에 위치할떄의 범위 모두 확인합니다
def canGo(y, x):
    flag = 0 <= x - 1 and x + 1 < C and y + 1 < R + 3
    flag = flag and (A[y - 1][x - 1] == 0)
    flag = flag and (A[y - 1][x] == 0)
    flag = flag and (A[y - 1][x + 1] == 0)
    flag = flag and (A[y][x - 1] == 0)
    flag = flag and (A[y][x] == 0)
    flag = flag and (A[y][x + 1] == 0)
    flag = flag and (A[y + 1][x] == 0)
    return flag

# 정령이 움직일 수 있는 모든 범위를 확인하고 도달할 수 있는 최하단 행을 반환합니다
def bfs(y, x):
    result = y
    q = deque([(y, x)])
    visit = [[False] * C for _ in range(R + 3)]
    visit[y][x] = True
    while q:
        cur_y, cur_x = q.popleft()
        for k in range(4):
            ny, nx = cur_y + dy[k], cur_x + dx[k]
            # 정령의 움직임은 골렘 내부이거나
            # 골렘의 탈출구에 위치하고 있다면 다른 골렘으로 옮겨 갈 수 있습니다
            if inRange(ny, nx) and not visit[ny][nx] and (A[ny][nx] == A[cur_y][cur_x] or (A[ny][nx] != 0 and isExit[cur_y][cur_x])):
                q.append((ny, nx))
                visit[ny][nx] = True
                result = max(result, ny)
    return result

# 골렘id가 중심 (y, x), 출구의 방향이 d일때 규칙에 따라 움직임을 취하는 함수입니다
# 1. 남쪽으로 한 칸 내려갑니다.
# 2. (1)의 방법으로 이동할 수 없으면 서쪽 방향으로 회전하면서 내려갑니다.
# 3. (1)과 (2)의 방법으로 이동할 수 없으면 동쪽 방향으로 회전하면서 내려갑니다.
def down(y, x, d, id):
    if canGo(y + 1, x):
        # 아래로 내려갈 수 있는 경우입니다
        down(y + 1, x, d, id)
    elif canGo(y + 1, x - 1):
        # 왼쪽 아래로 내려갈 수 있는 경우입니다
        down(y + 1, x - 1, (d + 3) % 4, id)
    elif canGo(y + 1, x + 1):
        # 오른쪽 아래로 내려갈 수 있는 경우입니다
        down(y + 1, x + 1, (d + 1) % 4, id)
    else:
        # 1, 2, 3의 움직임을 모두 취할 수 없을떄 입니다.
        if not inRange(y-1, x-1) or not inRange(y+1, x+1):
            # 숲을 벗어나는 경우 모든 골렘이 숲을 빠져나갑니다
            resetMap()
        else:
            # 골렘이 숲 안에 정착합니다
            A[y][x] = id
            for k in range(4):
                A[y + dy[k]][x + dx[k]] = id
            # 골렘의 출구를 기록하고
            isExit[y + dy[d]][x + dx[d]] = True
            global answer
            # bfs를 통해 정령이 최대로 내려갈 수 있는 행를 계산하여 누적합니다
            answer += bfs(y, x) - 3 + 1

def main():
    global R, C, K
    R, C, K = map(int, input().split())
    for id in range(1, K + 1): # 골렘 번호 id
        x, d = map(int, input().split()) # 골렘의 출발 x좌표, 방향 d를 입력받습니다
        down(0, x - 1, d, id)
    print(answer)

if __name__ == "__main__":
    main()